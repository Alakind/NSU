import lingo/pegcode/driver;
import math/math;
import string;

ArExpr ::= ArSum, ArMult, ArInt, ArSub, ArDiv, ArInv, ArRat, ArVar;

ArSum(lhs : ArExpr, rhs : ArExpr);
ArMult(lhs : ArExpr, rhs : ArExpr);
ArInt(val : int);
ArSub(lhs : ArExpr, rhs : ArExpr);
ArDiv(lhs : ArExpr, rhs : ArExpr);
ArInv(arg : ArExpr);
ArRat(num : int, denum : int);
ArVar(name : string);

Monome(monome: Tree<string, int>);
Polinome(monomes: Tree<Monome, int>);
RatFunc(num: Polinome, denum: Polinome);

ZERO_DIV = "Divison by zero";
INVALID_INPUT = "Invalid input";

s2ar(str : string) -> ArExpr {
	e_gr = "#include arith.lingo";
	parsic(
		compilePegGrammar(e_gr), 
		str,
		SemanticActions(setTree(defaultPegActions.t, "createArInt", \s -> ArInt(s2i(s[0]))))
	)
}

ar2s(expr : ArExpr) -> Maybe<string> {
	switch (expr : ArExpr) {
		ArInt(val): Some(i2s(val));
		ArSum(lhs, rhs): {
			left = ar2s(lhs);
			right = ar2s(rhs);
			str = ["(", left??left:ZERO_DIV, "+", right??right:ZERO_DIV, ")"];
			Some(strGlue(str, ""));
		}
		ArMult(lhs, rhs): {
			left = ar2s(lhs);
			right = ar2s(rhs);
			str = ["(", left??left:ZERO_DIV, "*", right??right:ZERO_DIV, ")"];
			Some(strGlue(str, ""));
		}
		ArSub(lhs, rhs): {
			left = ar2s(lhs);
			right = ar2s(rhs);
			str = ["(", left??left:ZERO_DIV, "-", right??right:ZERO_DIV, ")"];
			Some(strGlue(str, ""));
		}
		ArDiv(lhs, rhs): {
			left = ar2s(lhs);
			right = ar2s(rhs);
			str = ["(", left??left:ZERO_DIV, "/", right??right:ZERO_DIV, ")"];
			Some(strGlue(str, ""));
		}
		ArInv(value): {
			res = ar2s(value);
			Some(strGlue(["-", res??res:ZERO_DIV], ""));
		}
		ArRat(num, denum): {
			if (denum == 0) {
				None();
			} else if (denum / gcd(num, denum) == 1) {
				Some(i2s(num / gcd(num, denum)));
			} else {
				str = ["(", i2s(num / gcd(num, denum)), "/", i2s(denum / gcd(num, denum)), ")"];
				Some(strGlue(str, ""));
			}
		}
		ArVar(variable): Some(variable);
	}
}

varLookup(variable: string, variables: [Pair<string, ArRat>]) -> ArRat {
	fold(variables, ArRat(0, 0), \acc, cur_pair -> {
		if (firstOfPair(cur_pair) == variable) {
			ArRat(secondOfPair(cur_pair).num, secondOfPair(cur_pair).denum);
		} else {
			acc
		}
	})
}

// #########################################################################

ar2ArRat(expr: ArExpr) -> RatFunc {
	switch(expr) {
		ArVar(variable): {
			RatFunc(
				Polinome(makeTree1(Monome(makeTree1(variable, 1)), 1)),
				Polinome(makeTree1(Monome(makeTree()), 1)),
			);
		}
		ArInt(val): {
			RatFunc(
				Polinome(makeTree1(Monome(makeTree()), val)),
				Polinome(makeTree1(Monome(makeTree()), 1)),
			);
		}
		ArSum(lhs, rhs): {
			left = ar2ArRat(lhs);
			right = ar2ArRat(rhs);

			RatFunc(
				sumPolinomes(
					multPolinomes(left.num, right.denum),
					multPolinomes(right.num, left.denum)
				),
				multPolinomes(left.denum, right.denum)
			);
		}
		ArSub(lhs, rhs): {
			left = ar2ArRat(lhs);
			right = invRat(ar2ArRat(rhs));

			RatFunc(
				sumPolinomes(
					multPolinomes(left.num, right.denum),
					multPolinomes(right.num, left.denum)
				),
				multPolinomes(left.denum, right.denum)
			);
		}
		ArMult(lhs, rhs): {
			left = ar2ArRat(lhs);
			right = invRat(ar2ArRat(rhs));

			RatFunc(
				multPolinomes(left.num, right.num),
				multPolinomes(left.denum, right.denum)
			)
		}
		ArDiv(lhs, rhs): {
			left = ar2ArRat(lhs);
			right = invRat(ar2ArRat(rhs));

			RatFunc(
				multPolinomes(left.num, right.denum),
				multPolinomes(left.denum, right.num)
			);
		}
		ArInv(income): {
			in = ar2ArRat(income);

			invRat(in);
		}
		ArRat(num, denum): {
			RatFunc(
				Polinome(makeTree1(Monome(makeTree()), num)),
				Polinome(makeTree1(Monome(makeTree()), denum)),
			);
		}
	}
}

invRat(func: RatFunc) -> RatFunc {
	RatFunc(
        Polinome(mapTree(func.num.monomes, \monome -> -monome)),
        func.denum
    );
}

multPolinomes(left: Polinome, right: Polinome) -> Polinome {
	Polinome(
		foldTree(left.monomes, makeTree(), \left_monome, left_coef, left_acc -> {
			foldTree(right.monomes, left_acc, \right_monome, right_coef, right_acc -> {
				monome = Monome(mergeTreeCustom(left_monome.monome, right_monome.monome, \k, l, r -> l + r));
				res = lookupTree(right_acc, monome);

				res ?? setTree(right_acc, monome, res + right_coef * left_coef) : setTree(right_acc, monome, right_coef * left_coef);
			});
		})
	);
}

sumPolinomes(left: Polinome, right: Polinome) -> Polinome {
	Polinome(mergeTreeCustom(left.monomes, right.monomes, \k, left_coef, right_coef -> right_coef + left_coef));
}

ratFunc2s(func: RatFunc) -> string {
	left = polinome2s(func.num);
	right = polinome2s(func.denum);

	if (right == "") {
		ZERO_DIV;
	} else if (left == "") {
		"0";
	} else if (right == "1") {
		left;
	} else if (right == "-1") {
		func_inv = invRat(func);
		polinome2s(func_inv.num);
	} else {
		concatStrings(["(", left, ")", " / ", "(", right, ")"])
	};
}

polinome2s(polinome: Polinome) -> string {
	foldRTree(polinome.monomes, "", \monomes, coef, res -> {
		if (res == "") {
			if (coef >= 0) {
				monome2s(monomes, coef);
			} else {
				concatStrings(["-", monome2s(monomes, iabs(coef))]);
			}
		} else {
			monome_str = monome2s(monomes, coef);
			if (monome_str != "") {
				if (coef >= 0) {
        			concatStrings([res, " + ", monome2s(monomes, coef)]);
				} else {
					concatStrings([res, " - ", monome2s(monomes, iabs(coef))]);
				}
			} else {
				concatStrings([res, monome2s(monomes, coef)]);
			}
		}
	});
}

monome2s(monome: Monome, coef: int) -> string {
	if (coef == 0) {
		""
	} else if (coef == 1) {
		if (isEmptyTree(monome.monome)) {
			"1";
		} else {
			foldRTree(monome.monome, "", \mon, pow, res -> {
				if (pow == 1) {
					concatStrings([res, mon]);
				} else {
					concatStrings([res, mon, "^", "(", i2s(pow), ")"]);
				}
			});
		}
	} else {
		foldRTree(monome.monome, i2s(coef), \mon, pow, res -> {
            if(pow == 1) {
                concatStrings([res, mon]);
            } else {
                concatStrings([res, mon, "^", "(", i2s(pow), ")"]);
            }
        });
	}
}

// #########################################################################

differentiate(expr : ArExpr, var: string, variables: [Pair<string, ArRat>]) -> Maybe<ArExpr> {
	switch (expr: ArExpr) {
		ArVar(variable): {
			if (var == variable) {
				Some(ArRat(2, 2))
			} else {
				value = varLookup(variable, variables);
				if (value.denum == 0) {
					None()
				} else {
					Some(ArRat(0, 1))
				}
			}
		}
		ArInt(val): {
			Some(ArRat(0, 1));
		}
		ArSum(lhs, rhs): {
			leftOrNone = differentiate(lhs, var, variables);
			rightOrNone = differentiate(rhs, var, variables);

			if (isNone(leftOrNone) || isNone(rightOrNone)) {
				None()
			} else {
				left = leftOrNone??leftOrNone:ArRat(0, 0);
				right = rightOrNone??rightOrNone:ArRat(0, 0);


				newLeftOrNone = differentiate(left, var, variables);
				newRightOrNone = differentiate(right, var, variables);
				if (isNone(leftOrNone) || isNone(rightOrNone)) {
					None()
				} else {
					newLeft = newLeftOrNone??newLeftOrNone:ArRat(0, 0);
					newRight = newRightOrNone??newRightOrNone:ArRat(0, 0);

					Some(ArSum(newLeft, newRight))
				}
			}
		}
		ArSub(lhs, rhs): {
			leftOrNone = differentiate(lhs, var, variables);
			rightOrNone = differentiate(rhs, var, variables);

			if (isNone(leftOrNone) || isNone(rightOrNone)) {
				None();
			} else {
				left = leftOrNone??leftOrNone:ArRat(0, 0);
				right = rightOrNone??rightOrNone:ArRat(0, 0);


				newLeftOrNone = differentiate(left, var, variables);
				newRightOrNone = differentiate(right, var, variables);
				if (isNone(leftOrNone) || isNone(rightOrNone)) {
					None()
				} else {
					newLeft = newLeftOrNone??newLeftOrNone:ArRat(0, 0);
					newRight = newRightOrNone??newRightOrNone:ArRat(0, 0);

					Some(ArSub(newLeft, newRight))
				}
			}
		}
		ArMult(lhs, rhs): {
			leftOrNone = differentiate(lhs, var, variables);
			rightOrNone = differentiate(rhs, var, variables);

			if (isNone(leftOrNone) || isNone(rightOrNone)) {
				None();
			} else {
				left = leftOrNone??leftOrNone:ArRat(0, 0);
				right = rightOrNone??rightOrNone:ArRat(0, 0);


				newLeftOrNone = differentiate(left, var, variables);
				newRightOrNone = differentiate(right, var, variables);
				if (isNone(leftOrNone) || isNone(rightOrNone)) {
					None()
				} else {
					newLeft = newLeftOrNone??newLeftOrNone:ArRat(0, 0);
					newRight = newRightOrNone??newRightOrNone:ArRat(0, 0);

					Some(ArSum(ArMult(newLeft, right), ArMult(left, newRight)))
				}
			}
		}
		ArDiv(lhs, rhs): {
			leftOrNone = differentiate(lhs, var, variables);
			rightOrNone = differentiate(rhs, var, variables);


			left = leftOrNone??leftOrNone:ArRat(0, 0);
			right = rightOrNone??rightOrNone:ArRat(0, 0);


			newNumOrNone = differentiate(ArMult(left, right), var, variables);
			if (isNone(newNumOrNone)) {
				None()
			} else {
				newNum = newNumOrNone??newNumOrNone:ArRat(0, 0);

				Some(ArDiv(newNum, ArMult(right, right)))
			}
		}
		ArInv(income): {
			valueOrNone = differentiate(income, var, variables);

			if (isNone(valueOrNone)) {
				None()
			} else {
				value = valueOrNone??valueOrNone:ArRat(0, 0);

				Some(ArMult(ArRat(-1, 1), value))
			}
		}
		ArRat(num, denum): {
			if (num == 2 && denum == 2) {
				Some(ArRat(1, 1))
			} else {
				Some(ArRat(0, 1))
			}
		}
	}
}

// #########################################################################

simplify(expr: ArExpr) -> ArExpr {
	switch (expr : ArExpr) {
		ArVar(variable): {
			ArVar(variable)
		}
		ArInt(val): {
			ArRat(val, 1)
		}
		ArSum(lefths, righths): {
			lhs = simplify(lefths);
			rhs = simplify(righths);

			switch(lhs : ArExpr) {
				ArRat(lnum, ldenum): {
					switch(rhs : ArExpr) {
						ArRat(rnum, rdenum): {
							if (lnum == 0) {
								rhs
							} else if (rnum == 0) {
								lhs
							} else {
								ArSum(lhs, rhs)
							}
						}
						default: {
							if (lnum == 0) {
								rhs
							} else {
								ArSum(lhs, rhs)
							}
						}
					}
				}
				default: {
					switch(rhs : ArExpr) {
						ArRat(rnum, rdenum): {
							if (rnum == 0) {
								lhs
							} else {
								ArSum(lhs, rhs)
							}
						}
						default: {
							ArSum(lhs, rhs)
						}
					}
				}
			}
		}
		ArSub(lefths, righths): {
			lhs = simplify(lefths);
			rhs = simplify(righths);

			switch(lhs : ArExpr) {
				ArRat(lnum, ldenum): {
					switch(rhs : ArExpr) {
						ArRat(rnum, rdenum): {
							if (lnum == 0) {
								ArInv(rhs)
							} else if (rnum == 0) {
								lhs
							} else {
								ArSub(lhs, rhs)
							}
						}
						default: {
							if (lnum == 0) {
								ArInv(rhs)
							} else {
								ArSub(lhs, rhs)
							}
						}
					}
				}
				default: {
					switch(rhs : ArExpr) {
						ArRat(rnum, rdenum): {
							if (rnum == 0) {
								lhs
							} else {
								ArSub(lhs, rhs)
							}
						}
						default: {
							ArSub(lhs, rhs)
						}
					}
				}
			}
		}
		ArMult(lefths, righths): {
			lhs = simplify(lefths);
			rhs = simplify(righths);

			switch(lhs : ArExpr) {
				ArRat(lnum, ldenum): {
					switch(rhs : ArExpr) {
						ArRat(rnum, rdenum): {
							if (lnum == 0 || rnum == 0) {
								ArRat(0, 1)
							} else {
								ArMult(lhs, rhs)
							}
						}
						default: {
							if (lnum == 0) {
								ArRat(0, 1)
							} else {
								ArMult(lhs, rhs)
							}
						}
					}
				}
				default: {
					switch(rhs : ArExpr) {
						ArRat(rnum, rdenum): {
							if (rnum == 0) {
								ArRat(0, 1)
							} else {
								ArMult(lhs, rhs)
							}
						}
						default: {
							ArMult(lhs, rhs)
						}
					}
				}
			}
		}
		ArDiv(lefths, righths): {
			lhs = simplify(lefths);
			rhs = simplify(righths);

			switch(lhs : ArExpr) {
				ArRat(lnum, ldenum): {
					switch(rhs : ArExpr) {
						ArRat(rnum, rdenum): {
							if (lnum == 0) {
								ArRat(0, 1)
							} else {
								ArDiv(lhs, rhs)
							}
						}
						default: {
							ArDiv(lhs, rhs)
						}
					}
				}
				default: {
					ArDiv(lhs, rhs)
				}
			}
		}
		ArInv(income): {
			ArInv(income)
		}
		ArRat(num, denum): {
			gcd = iabs(gcd(num, denum));

			ArRat(num / gcd, denum / gcd)
		}
	}
}

// #########################################################################

calculate(expr : ArExpr, variables: [Pair<string, ArRat>]) -> Maybe<ArRat> {
	switch (expr : ArExpr) {
		ArVar(variable): {
			value = varLookup(variable, variables);

			if (value.denum == 0) {
				None()
			} else {
				Some(value)
			}
		}
		ArInt(val): {
			Some(ArRat(val, 1))
		}
		ArSum(lhs, rhs): {
			leftOrNone = calculate(lhs, variables);
			rightOrNone = calculate(rhs, variables);

			if (isNone(leftOrNone) || isNone(rightOrNone)) {
				None()
			} else {
				left = leftOrNone??leftOrNone:ArRat(0, 0);
				right = rightOrNone??rightOrNone:ArRat(0, 0);

				if (left.denum == 0 || right.denum == 0) {
					None()
				} else {
					if (left.denum == right.denum) {
						Some(ArRat(left.num + right.num, left.denum))
					} else {
						lcm = lcm(left.denum, right.denum);
						Some(ArRat((left.num * (lcm / left.denum)) + (right.num * (lcm / right.denum)), lcm))
					}
				}
			}
		}
		ArSub(lhs, rhs): {
			leftOrNone = calculate(lhs, variables);
			rightOrNone = calculate(rhs, variables);

			if (isNone(leftOrNone) || isNone(rightOrNone)) {
				None();
			} else {
				left = leftOrNone??leftOrNone:ArRat(0, 0);
				right = rightOrNone??rightOrNone:ArRat(0, 0);

				if (left.denum == 0 || right.denum == 0) {
					None()
				} else {
					if (left.denum == right.denum) {
						Some(ArRat(left.num - right.num, left.denum))
					} else {
						lcm = lcm(left.denum, right.denum);
						Some(ArRat((left.num * (lcm / left.denum)) - (right.num * (lcm / right.denum)), lcm))
					}
				}
			}
		}
		ArMult(lhs, rhs): {
			leftOrNone = calculate(lhs, variables);
			rightOrNone = calculate(rhs, variables);

			if (isNone(leftOrNone) || isNone(rightOrNone)) {
				None();
			} else {
				left = leftOrNone??leftOrNone:ArRat(0, 0);
				right = rightOrNone??rightOrNone:ArRat(0, 0);

				if (left.denum == 0 || right.denum == 0) {
					None()
				} else {
					gcd = iabs(gcd(left.num * right.num, left.denum * right.denum));
					Some(ArRat((left.num * right.num) / gcd, (left.denum * right.denum) / gcd))
				}
			}
		}
		ArDiv(lhs, rhs): {
			leftOrNone = calculate(lhs, variables);
			rightOrNone = calculate(rhs, variables);

			if (isNone(leftOrNone) || isNone(rightOrNone)) {
				None();
			} else {
				left = leftOrNone??leftOrNone:ArRat(0, 0);
				right = rightOrNone??rightOrNone:ArRat(0, 0);

				if (left.denum == 0 || right.denum == 0) {
					None()
				} else {
					gcd = iabs(gcd(left.num * right.denum, left.denum * right.num));
					Some(ArRat(((left.num * right.denum) / gcd), ((left.denum * right.num) / gcd)))
				}
			}
		}
		ArInv(income): {
			valueOrNone = calculate(income, variables);

			if (isNone(valueOrNone)) {
				None()
			} else {
				value = valueOrNone??valueOrNone:ArRat(0, 0);
				if (value.denum == 0) {
					None()
				} else {
					Some(ArRat(-1 * value.num, value.denum))
				}
			}
		}
		ArRat(num, denum): {
			if (denum == 0) {
				None()
			} else {
				Some(ArRat(num, denum))
			}
		}
	}
}

resolve(arrExpr: ArExpr, variables: [Pair<string, ArRat>]) -> void {
	result = calculate(arrExpr, variables);

	res = result??result:ArRat(0, 0);

	if (isNone(result) || isNone(ar2s(res))) {
		println(ZERO_DIV)
	} else {
		result ?? println(result) : println(INVALID_INPUT)
	}
}

resolveDiff(arrExpr: ArExpr, var: string, variables: [Pair<string, ArRat>]) -> void {
	result = differentiate(arrExpr, "x", variables);
	
	result ?? println(result) : println(INVALID_INPUT)
}

main() {
	s = "((((x - 6) / (6 * y)) / (((x * x) - (y * y)) / y)) * (((x * x) + ((2 * (x * y)) + (y * y))) / x))";
    tree = s2ar(s);
	println(ratFunc2s(ar2ArRat(tree)));
}
